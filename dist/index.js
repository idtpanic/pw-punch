var L=1e5,M=500000,I=3600,H=1e4,X=new TextEncoder,K=[256,512],v=150000,F=256,O="RS256";async function k(z){return crypto.subtle.importKey("raw",X.encode(z),{name:"PBKDF2"},!1,["deriveBits"])}async function R(z,Q,Z,$){return crypto.subtle.deriveBits({name:"PBKDF2",salt:Q,iterations:Z,hash:$},z,256)}function N(z,Q){let Z=Math.floor(Date.now()/1000);if(z.exp!==void 0&&Z>=z.exp)return!1;if(z.nbf!==void 0&&Z<z.nbf)return!1;if(z.iat!==void 0&&Z<z.iat-5)return!1;if(Q?.iss&&z.iss!==Q.iss)return!1;if(Q?.sub&&z.sub!==Q.sub)return!1;if(Q?.aud&&z.aud!==Q.aud)return!1;return!0}function U(z,Q){if(!(z instanceof Uint8Array)||!(Q instanceof Uint8Array))throw TypeError("Inputs must be Uint8Arrays");if(Math.max(z.length,Q.length)>H)throw Error("Input too large");let Z=0,$=Math.max(z.length,Q.length);for(let q=0;q<$;q++){let G=q<z.length?z[q]:0,j=q<Q.length?Q[q]:0;Z|=G^j}return Z===0}function V(z){z=z.replace(/-/g,"+").replace(/_/g,"/");while(z.length%4!==0)z+="=";return Uint8Array.from(atob(z),(Q)=>Q.charCodeAt(0))}function J(z){let Q=typeof z==="string"?z:String.fromCharCode(...z);return btoa(Q).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function w(z){z=z.replace(/-/g,"+").replace(/_/g,"/");while(z.length%4!==0)z+="=";return atob(z)}function S(z,Q={}){let Z=Math.floor(Date.now()/1000),$=z.iat??Q.iat??Z,q=z.nbf??Q.nbf??$,G=Q.expSeconds??I,j=z.exp??Q.exp??$+G;return{...z,iat:$,nbf:q,exp:j}}function W(z){try{return JSON.parse(w(z))}catch{return null}}async function D(z,Q=F,Z=v){if(Z<L||Z>M)throw Error(`Iterations must be between ${L} and ${M}`);if(!K.includes(Q))throw Error("Only SHA-256 and SHA-512 are supported");let $=crypto.getRandomValues(new Uint8Array(32)),q=await k(z),G=await R(q,$,Z,`SHA-${Q}`),j=btoa(String.fromCharCode(...$)),C=btoa(String.fromCharCode(...new Uint8Array(G)));return`${j}:${C}`}async function _(z,Q,Z=F,$=v){let[q,G]=Q.split(":");if(!q||!G)return!1;let j=V(q),C=V(G),Y=await k(z),x=await R(Y,j,$,`SHA-${Z}`);return U(new Uint8Array(x),C)}async function P(z,Q,Z){let $=S(Q),q={alg:O,...Z?.kid?{kid:Z.kid}:{},...Z?.includeTyp!==!1?{typ:"JWT"}:{}},G,j;try{G=J(JSON.stringify(q)),j=J(JSON.stringify($))}catch{throw Error("Failed to encode token payload or header")}let C=`${G}.${j}`,Y=await crypto.subtle.sign({name:"RSASSA-PKCS1-v1_5"},z,X.encode(C)),x=J(new Uint8Array(Y));return`${G}.${j}.${x}`}async function A(z,Q,Z){let[$,q,G]=z.split(".");if(!$||!q||!G||G.length>1024)return null;let j=W($);if(!j||j.alg!==O)return null;if(!(Q instanceof CryptoKey))return null;let C=`${$}.${q}`;if(!await crypto.subtle.verify({name:"RSASSA-PKCS1-v1_5"},Q,V(G),X.encode(C)))return null;let x=W(q);if(!x||!N(x))return null;if(Z&&!Z(x))return null;return x}function m(z){let[Q,Z,$]=z.split(".");return{header:Q?W(Q):null,payload:Z?W(Z):null,signature:$??null}}export{A as verifyToken,_ as verifyPassword,P as signToken,D as hashPassword,m as decodeToken};
